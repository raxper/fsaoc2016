<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharpPlus</name></assembly>
<members>
<member name="T:FSharpPlus.Identity`1">
 <summary> Computation type: Simple function application.
 <para/>   Binding strategy: The bound function is applied to the input value. Identity x >>= f = Identity (f x)
 <para/>   Useful for: Lens setters and updaters - Monads can be derived from monad transformers applied to the Identity monad.
 <para/>   The Identity monad is a monad that does not embody any computational strategy. 
           It simply applies the bound function to its input without any modification. 
           Computationally, there is no reason to use the Identity monad instead of the much simpler act of simply applying functions to their arguments.
           The purpose of the Identity monad is its fundamental role in the theory of monad transformers.
           Any monad transformer applied to the Identity monad yields a non-transformer version of that monad.
           Its applicative instance plays a fundamental role in Lens. </summary> 
</member>
<member name="M:FSharpPlus.Compatibility.Haskell.return'``2(``0)">
<summary>
 Monad
</summary>
</member>
<member name="M:FSharpPlus.Compatibility.Haskell.op_Dereference``2(``0)">
<summary>
 converts a string to list&lt;char&gt; otherwise still works as dereference operator.
</summary>
</member>
<member name="T:FSharpPlus.Data.All">
<summary>
 Boolean monoid under conjunction.
</summary>
</member>
<member name="T:FSharpPlus.Data.Any">
<summary>
 Boolean monoid under disjunction.
</summary>
</member>
<member name="T:FSharpPlus.Data.Cont`2">
 <summary> Computation type: Computations which can be interrupted and resumed.
 <para/>   Binding strategy: Binding a function to a monadic value creates a new continuation which uses the function as the continuation of the monadic computation.
 <para/>   Useful for: Complex control structures, error handling, and creating co-routines.</summary>
</member>
<member name="T:FSharpPlus.Data.Dual`1">
<summary>
 The dual of a monoid, obtained by swapping the arguments of append.
</summary>
</member>
<member name="T:FSharpPlus.Data.Endo`1">
<summary>
 The monoid of endomorphisms under composition.
</summary>
</member>
<member name="T:FSharpPlus.Data.First`1">
<summary>
 Option&lt;&apos;T&gt; monoid returning the leftmost non-None value.
</summary>
</member>
<member name="T:FSharpPlus.Data.Last`1">
<summary>
 Option&lt;&apos;T&gt; monoid returning the rightmost non-None value.
</summary>
</member>
<member name="T:FSharpPlus.Data.Reader`2">
 <summary> Computation type: Computations which read values from a shared environment.
 <para/>   Binding strategy: Monad values are functions from the environment to a value. The bound function is applied to the bound value, and both have access to the shared environment.
 <para/>   Useful for: Maintaining variable bindings, or other shared environment.</summary>
</member>
<member name="T:FSharpPlus.Data.State`2">
 <summary> Computation type: Computations which maintain state.
 <para/>   Binding strategy: Threads a state parameter through the sequence of bound functions so that the same state value is never used twice, giving the illusion of in-place update.
 <para/>   Useful for: Building computations from sequences of operations that require a shared state. </summary>
</member>
<member name="T:FSharpPlus.Data.Writer`2">
 <summary> Computation type: Computations which produce a stream of data in addition to the computed values.
 <para/>   Binding strategy: Combines the outputs of the subcomputations using <c>mappend</c>.
 <para/>   Useful for: Logging, or other computations that produce output "on the side". </summary>
</member>
<member name="M:FSharpPlus.Data.Cont.callCC``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Cont{``1,``2}},FSharpPlus.Data.Cont{``1,``0}})">
<summary>
 (call-with-current-continuation) calls a function with the current continuation as its argument.
</summary>
</member>
<member name="M:FSharpPlus.Data.Reader.local``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.Reader{``1,``2})">
 <summary> Executes a computation in a modified environment. </summary>
 <param name="f"> The function to modify the environment.    </param>
 <param name="m"> Reader to run in the modified environment. </param>
</member>
<member name="M:FSharpPlus.Data.Reader.ask``1">
<summary>
 Retrieves the monad environment.
</summary>
</member>
<member name="T:FSharpPlus.Data.ResultOrException">
<summary>
 Choice&lt;&apos;TSuccess,&apos;TFailure&gt; specialized in &apos;TFailure = Exception 
</summary>
</member>
<member name="M:FSharpPlus.Data.State.put``1(``0)">
<summary>
 Replace the state inside the monad.
</summary>
</member>
<member name="M:FSharpPlus.Data.State.get``1">
<summary>
 Return the state from the internals of the monad.
</summary>
</member>
<member name="M:FSharpPlus.Data.Writer.pass``2(FSharpPlus.Data.Writer{``0,System.Tuple{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}})">
<summary>
 Action that executes the action m, which returns a value and a function, and returns the value, applying the function to the output.
</summary>
</member>
<member name="M:FSharpPlus.Data.Writer.listen``2(FSharpPlus.Data.Writer{``0,``1})">
 <summary> An action that executes the action <paramref name="m"/> and adds its output
 to the value of the computation. </summary>
 <param name="m">The action to be executed.</param>
</member>
<member name="M:FSharpPlus.Data.Writer.tell``1(``0)">
<summary>
 Embeds a simple writer action.
</summary>
</member>
<member name="M:FSharpPlus.Data.Writer.exec``3(FSharpPlus.Data.Writer{FSharpPlus.Data.Writer{``0,``1},``2})">
<summary>
 Extract the output from a writer computation.
</summary>
</member>
<member name="M:FSharpPlus.Data.Writer.run``2(FSharpPlus.Data.Writer{``0,``1})">
<summary>
 Unwraps a writer computation as a (result, output) pair. (The inverse of Writer.)
</summary>
</member>
<member name="M:FSharpPlus.Lens.choosing``10(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``9,``4}},``0,Microsoft.FSharp.Core.FSharpChoice{``9,``1})">
<summary>
 Merge two lenses, getters, setters, folds or traversals.
</summary>
</member>
<member name="M:FSharpPlus.Lens.iso``8(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3})">
<summary>
 Build an iso from a pair of inverse functions.
</summary>
</member>
<member name="M:FSharpPlus.Lens.prism``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpChoice{``3,``1}})">
<summary>
 Build a Prism using Choice instead of Option to permit the types of &apos;s and &apos;t to differ.
</summary>
</member>
<member name="M:FSharpPlus.Lens.lens``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``3}},Microsoft.FSharp.Core.FSharpFunc{``1,``4},``0)">
<summary>
 Build a &apos;Lens&apos; from a getter and a setter.
</summary>
</member>
<member name="T:FSharpPlus.Operators.Result`2">
<summary>
 A convenient alias for Choice&lt;&apos;T1,&apos;T2&gt;
</summary>
</member>
<member name="M:FSharpPlus.Operators.liftM``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Equivalent to map but only for Monads.
</summary>
</member>
<member name="M:FSharpPlus.Operators.|Parse|_|``1(System.String)">
<summary>
 An active recognizer for a generic value parser.
</summary>
</member>
<member name="M:FSharpPlus.Operators.implicit``2(``0)">
<summary>
 Converts using the implicit operator. 
</summary>
</member>
<member name="M:FSharpPlus.Operators.sum``3(``0)">
<summary>
 Returns the sum of the elements in the Foldable.
</summary>
</member>
<member name="M:FSharpPlus.Operators.mfilter``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
<summary>
 Generic filter operation for MonadZero. It returns all values satisfying the predicate, if the predicate returns false will use the mzero value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.mfold``2(``0)">
<summary>
 Folds a Foldable of a Monoid, using its empty as initial state and append as folder.
</summary>
</member>
<member name="M:FSharpPlus.Operators.choice``2(``0)">
<summary>
 Fold using alternative operator `&lt;|&gt;`
</summary>
</member>
<member name="M:FSharpPlus.Operators.abs'``1(``0)">
 <summary> Gets the absolute value of a number.
           Works also for unsigned types. 
 <para/>   Rule: signum x * abs x = x        </summary>
</member>
<member name="M:FSharpPlus.Operators.abs``1(``0)">
 <summary> Gets the absolute value of a number.
 <para/>   Rule: signum x * abs x = x        </summary>
</member>
<member name="M:FSharpPlus.Operators.signum'``1(``0)">
 <summary> Returns a number which represents the sign.
           Works also for unsigned types. 
 <para/>   Rule: signum x * abs x = x        </summary>
</member>
<member name="M:FSharpPlus.Operators.signum``1(``0)">
 <summary> Returns a number which represents the sign.
 <para/>   Rule: signum x * abs x = x        </summary>
</member>
<member name="M:FSharpPlus.Operators.sqrtRem``1(``0)">
<summary>
 Returns the square root of an integral number.
</summary>
</member>
<member name="M:FSharpPlus.Operators.isqrt``1(``0)">
<summary>
 Returns the square root of an integral number.
</summary>
</member>
<member name="M:FSharpPlus.Operators.trySqrt``1(``0)">
<summary>
 Returns the square root of a number of any type. Returns None if there is no square root.
</summary>
</member>
<member name="M:FSharpPlus.Operators.sqrt``1(``0)">
<summary>
 Returns the square root of a number of any type. Throws an exception if there is no square root.
</summary>
</member>
<member name="M:FSharpPlus.Operators.tryDiv``1(``0,``0)">
<summary>
 Returns the division between two numbers. Returns None if the numbers are not divisible.
</summary>
</member>
<member name="M:FSharpPlus.Operators.div``1(``0,``0)">
<summary>
 Returns the division between two numbers. If the numbers are not divisible throws an error.
</summary>
</member>
<member name="M:FSharpPlus.Operators.trySubtract``1(``0,``0)">
<summary>
 Returns the subtraction between two numbers. Returns None if the result is negative on unsigned types.
</summary>
</member>
<member name="M:FSharpPlus.Operators.subtract``1(``0,``0)">
<summary>
 Returns the subtraction between two numbers. Throws an error if the result is negative on unsigned types.
</summary>
</member>
<member name="M:FSharpPlus.Operators.tryNegate'``1(``0)">
<summary>
 Returns the additive inverse of the number.
 Works also for unsigned types (Returns none if there is no inverse).
</summary>
</member>
<member name="M:FSharpPlus.Operators.negate'``1(``0)">
<summary>
 Returns the additive inverse of the number.
 Works also for unsigned types (Throws an exception if there is no inverse).
</summary>
</member>
<member name="M:FSharpPlus.Operators.negate``1(``0)">
<summary>
 Returns the additive inverse of the number.
</summary>
</member>
<member name="M:FSharpPlus.Operators.getPi``1">
<summary>
 Gets the pi number.
</summary>
</member>
<member name="M:FSharpPlus.Operators.toBigInt``1(``0)">
<summary>
 Converts to BigInteger.
</summary>
</member>
<member name="M:FSharpPlus.Operators.fromBigInt``1(System.Numerics.BigInteger)">
<summary>
 Converts from BigInteger to the inferred destination type.
</summary>
</member>
<member name="M:FSharpPlus.Operators.maxValue``1">
<summary>
 Returns the largest possible value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.minValue``1">
<summary>
 Returns the smallest possible value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.divRem``1(``0,``0)">
<summary>
 Divides one number by another, returns a tuple with the result and the remainder.
</summary>
</member>
<member name="M:FSharpPlus.Operators.getOne``1">
<summary>
 Gets a value that represents the number 1 (one).
</summary>
</member>
<member name="M:FSharpPlus.Operators.getZero``1">
<summary>
 Gets a value that represents the number 0 (zero).
</summary>
</member>
<member name="M:FSharpPlus.Operators.tryParse``1(System.String)">
<summary>
 Converts to a value from its string representation. Returns None if the convertion doesn&apos;t succeed.
</summary>
</member>
<member name="M:FSharpPlus.Operators.parse``1(System.String)">
<summary>
 Converts to a value from its string representation.
</summary>
</member>
<member name="M:FSharpPlus.Operators.explicit``2(``0)">
<summary>
 Convert using the explicit operator.
</summary>
</member>
<member name="M:FSharpPlus.Operators.item5``2(``0)">
<summary>
 Gets the value of the fifth component of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.item4``2(``0)">
<summary>
 Gets the value of the fourth component of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.item3``2(``0)">
<summary>
 Gets the value of the third component of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.item2``2(``0)">
<summary>
 Gets the value of the second component of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.item1``2(``0)">
<summary>
 Gets the value of the first component of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.chunkBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
 <summary>Applies a key-generating function to each element of a collection and yields a collection of 
 keys. Each key contains a collection of all adjacent elements that match 
 to this key.</summary>
 
 <remarks>The function makes no assumption on the ordering of the original 
 collection.</remarks>

 <param name="projection">A function that transforms an element of the collection into a comparable key.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>
</member>
<member name="M:FSharpPlus.Operators.groupBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
 <summary>Applies a key-generating function to each element of a collection and yields a collection of 
 unique keys. Each unique key contains a collection of all elements that match 
 to this key.</summary>
 
 <remarks>This function returns a collection that digests the whole initial collection as soon as 
 that collection is iterated. As a result this function should not be used with 
 large or infinite collections. The function makes no assumption on the ordering of the original 
 collection.</remarks>

 <param name="projection">A function that transforms an element of the collection into a comparable key.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>
</member>
<member name="M:FSharpPlus.Operators.limit``1(System.Int32,``0)">
 <summary>Returns a collection with at most N elements.</summary>

 <param name="count">The maximum number of items to return.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharpPlus.Operators.drop``1(System.Int32,``0)">
 <summary>Returns a collection that drops N elements of the original collection and then yields the
 remaining elements of the collection.</summary>
 <param name="count">The number of items to drop.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>
</member>
<member name="M:FSharpPlus.Operators.take``1(System.Int32,``0)">
 <summary>Returns the first N elements of the collection.</summary>
 <remarks>Throws <c>InvalidOperationException</c>
 if the count exceeds the number of elements in the collection. <c>limit</c>
 returns as many items as the collection contains instead of throwing an exception.</remarks>

 <param name="count">The number of items to take.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input collection is empty.</exception>
 <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the collection.</exception>
</member>
<member name="M:FSharpPlus.Operators.skip``1(System.Int32,``0)">
 <summary>Returns a collection that skips N elements of the original collection and then yields the
 remaining elements of the collection.</summary>
 <remarks>Throws <c>InvalidOperationException</c>
 when count exceeds the number of elements in the collection. <c>drop</c>
 returns an empty collection instead of throwing an exception.</remarks>
 <param name="count">The number of items to skip.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
 <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the collection.</exception>
</member>
<member name="M:FSharpPlus.Operators.catch``3(``0,Microsoft.FSharp.Core.FSharpFunc{``2,``1})">
 <summary> Executes a handler when the value contained in the Error monad represents an error.  </summary>
</member>
<member name="M:FSharpPlus.Operators.throw``2(``0)">
<summary>
 Throws an error value inside the Error monad.
</summary>
</member>
<member name="M:FSharpPlus.Operators.pass``2(``0)">
<summary>
 Action that executes the action m, which returns a value and a function, and returns the value, applying the function to the output.
</summary>
</member>
<member name="M:FSharpPlus.Operators.listen``2(``0)">
 <summary> An action that executes the action <paramref name="m"/> and adds its output to the value of the computation. </summary>
 <param name="m">The action to be executed.</param>
</member>
<member name="M:FSharpPlus.Operators.tell``2(``0)">
<summary>
 Embeds a simple writer action.
</summary>
</member>
<member name="M:FSharpPlus.Operators.local``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
 <summary> Executes a computation in a modified environment. </summary>
 <param name="f"> The function to modify the environment.    </param>
 <param name="m"> Reader to run in the modified environment. </param>
</member>
<member name="M:FSharpPlus.Operators.put``2(``0)">
<summary>
 Replace the state inside the monad.
</summary>
</member>
<member name="M:FSharpPlus.Operators.callCC``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2})">
<summary>
 (call-with-current-continuation) calls a function with the current continuation as its argument.
</summary>
</member>
<member name="M:FSharpPlus.Operators.liftAsync``2(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 A lift specializaed for Async&lt;&apos;T&gt; which is able to bring an Async value from any depth of monad-layers.
</summary>
</member>
<member name="M:FSharpPlus.Operators.lift``2(``0)">
<summary>
 Lift a computation from the inner monad to the constructed monad.
</summary>
</member>
<member name="M:FSharpPlus.Operators.traversei``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``3)">
<summary>
 Traverse an indexed container. Behaves exactly like a regular traverse except that the traversing function also has access to the key associated with a value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.foldi``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,``3)">
<summary>
 Left-associative fold of an indexed container with access to the index i.
</summary>
</member>
<member name="M:FSharpPlus.Operators.iteri``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},``2)">
<summary>
 Map an action with access to an index.
</summary>
</member>
<member name="M:FSharpPlus.Operators.mapi``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``3)">
<summary>
 Map with access to the index.
</summary>
</member>
<member name="M:FSharpPlus.Operators.item``3(``0,``1)">
<summary>
 Get an item from the given index.
</summary>
</member>
<member name="M:FSharpPlus.Operators.sequenceA``2(``0)">
<summary>
 Evaluate each action in the structure from left to right, and and collect the results.
</summary>
</member>
<member name="M:FSharpPlus.Operators.traverse``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.
</summary>
</member>
<member name="M:FSharpPlus.Operators.getApp``1">
<summary>
 Apply an arrow produced as the output of some previous computation to an input, producing its output as the output of app. 
</summary>
</member>
<member name="M:FSharpPlus.Operators.right``2(``0)">
<summary>
 Feed marked inputs through the right argument arrow, passing the rest through unchanged to the output.
</summary>
</member>
<member name="M:FSharpPlus.Operators.left``2(``0)">
<summary>
 Feed marked inputs through the left argument arrow, passing the rest through unchanged to the output.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_PlusPlusPlus``3(``0,``1)">
<summary>
 Split the input between both argument arrows, retagging and merging their outputs. Note that this is in general not a functor.
</summary>
</member>
<member name="M:FSharpPlus.Operators.fanin``3(``0,``1)">
<summary>
 Split the input between the two argument arrows and merge their outputs. Also known as the (|||) operator.
</summary>
</member>
<member name="M:FSharpPlus.Operators.fanout``3(``0,``1)">
<summary>
 Send the input to both argument arrows and combine their output. Also known as the (&amp;&amp;&amp;) operator.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_MultiplyMultiplyMultiply``3(``0,``1)">
<summary>
 Split the input between the two argument arrows and combine their output. Note that this is in general not a functor.
</summary>
</member>
<member name="M:FSharpPlus.Operators.arrSecond``2(``0)">
<summary>
 Send the second component of the input through the argument arrow, and copy the rest unchanged to the output.
</summary>
</member>
<member name="M:FSharpPlus.Operators.arrFirst``2(``0)">
<summary>
 Send the first component of the input through the argument arrow, and copy the rest unchanged to the output.
</summary>
</member>
<member name="M:FSharpPlus.Operators.arr``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Lift a function to an arrow.
</summary>
</member>
<member name="M:FSharpPlus.Operators.catComp``3(``0,``1)">
<summary>
 Right-to-left morphism composition.
</summary>
</member>
<member name="M:FSharpPlus.Operators.getCatId``1">
<summary>
 the identity morphism.
</summary>
</member>
<member name="M:FSharpPlus.Operators.join``2(``0)">
<summary>
 Flattens two layers of monadic information into one.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Takes a function from a plain type to a monadic value and a monadic value, and returns a new monadic value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_GreaterGreaterEquals``3(``0,Microsoft.FSharp.Core.FSharpFunc{``2,``1})">
<summary>
 Takes a monadic value and a function from a plain type to a monadic value, and returns a new monadic value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.liftA2``7(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``3,``5)">
<summary>
 Apply 2 lifted arguments to a lifted function.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_LessMultiplyGreater``3(``0,``1)">
<summary>
 Apply a lifted argument to a lifted function.
</summary>
</member>
<member name="M:FSharpPlus.Operators.result``2(``0)">
<summary>
 Lift a value into a Functor. Same as return in Computation Expressions.
</summary>
</member>
<member name="M:FSharpPlus.Operators.iter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``1)">
<summary>
 Like map but ignoring the results.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_BarGreaterGreater``4(``0,Microsoft.FSharp.Core.FSharpFunc{``2,``3})">
<summary>
 Lift a function into a Functor. Same as map but with flipped arguments.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_LessLessBar``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Lift a function into a Functor. Same as map.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_LessBangGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Lift a function into a Functor. Same as map.
</summary>
</member>
<member name="M:FSharpPlus.Operators.map``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Lift a function into a Functor.
</summary>
</member>
<member name="M:FSharpPlus.Operators.GenericMath.gcd``1(``0,``0)">
<summary>
 Greatest Common Divisor
</summary>
</member>
<member name="M:FSharpPlus.Operators.GenericMath.divRemE``1(``0,``0)">
<summary>
 Euclidean division-remainder, following the mathematical convention where the mod is always positive.
</summary>
</member>
<member name="M:FSharpPlus.Operators.GenericMath.remE``1(``0,``0)">
<summary>
 Euclidean remainder of integer division, following the mathematical convention where the mod is always positive.
</summary>
</member>
<member name="M:FSharpPlus.Operators.GenericMath.rem``1(``0,``0)">
<summary>
 Remainder of Integer division. Same as (%).
</summary>
</member>
<member name="M:FSharpPlus.Operators.GenericMath.divE``1(``0,``0)">
<summary>
 Euclidean integer division, following the mathematical convention where the mod is always positive.
</summary>
</member>
<member name="M:FSharpPlus.Operators.GenericMath.div``1(``0,``0)">
<summary>
 Integer division. Same as (/) for Integral types.
</summary>
</member>
<member name="T:FSharpPlus.Operators.GenericMath">
 <summary>
 Generic numbers, functions and operators.
 By opening this module some common operators become restricted, like (+) to 'a->'a->'a 
 </summary>
</member>
<member name="T:FSharpPlus.Operators.ApplicativeMath">
 <summary>Math Operators ready to use over Applicative Functors.</summary>
</member>
<member name="M:FSharpPlus.Operators.Arrows.op_BitwiseOr``3(``0,``1)">
<summary>
 Split the input between the two argument arrows and merge their outputs. Also known as fanin.
</summary>
</member>
<member name="M:FSharpPlus.Operators.Arrows.op_BitwiseAnd``3(``0,``1)">
<summary>
 Send the input to both argument arrows and combine their output. Also known as fanout.
</summary>
</member>
<member name="M:FSharpPlus.Operators.Arrows.op_RightShift``3(``0,``1)">
<summary>
 Left-to-right morphism composition.
</summary>
</member>
<member name="M:FSharpPlus.Operators.Arrows.op_LeftShift``3(``0,``1)">
<summary>
 Right-to-left morphism composition.        
</summary>
</member>
<member name="T:FSharpPlus.Operators.Arrows">
 <summary>Additional operators for Arrows related functions which shadows some F# operators for bitwise functions.</summary>
</member>
</members>
</doc>
